#!/usr/bin/env python3
"""Fast, customizable Roblox username checker/sniper.

Features:
- Choose character types (letters, numbers, lowercase/uppercase)
- Choose min/max username length
- Multi-threaded checks for higher throughput
- Optional prefix/suffix filters
- Continuous mode until desired number of available usernames are found
"""

from __future__ import annotations

import argparse
import json
import random
import string
import threading
import time
import urllib.error
import urllib.parse
import urllib.request
from concurrent.futures import FIRST_COMPLETED, Future, ThreadPoolExecutor, wait

ROBLOX_VALIDATE_URL = "https://auth.roblox.com/v1/usernames/validate"
DEFAULT_BIRTHDAY = "2000-01-01T00:00:00.000Z"


class Stats:
    def __init__(self) -> None:
        self.checked = 0
        self.available = 0
        self.failed = 0
        self.lock = threading.Lock()

    def add_checked(self, available: bool) -> None:
        with self.lock:
            self.checked += 1
            if available:
                self.available += 1

    def add_failed(self) -> None:
        with self.lock:
            self.failed += 1

    def snapshot(self) -> tuple[int, int, int]:
        with self.lock:
            return self.checked, self.available, self.failed


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Fast Roblox username checker/sniper with customizable filters"
    )
    parser.add_argument("--min-length", type=int, default=3, help="Minimum username length")
    parser.add_argument("--max-length", type=int, default=12, help="Maximum username length")
    parser.add_argument("--letters", action="store_true", help="Include letters")
    parser.add_argument("--numbers", action="store_true", help="Include numbers")
    parser.add_argument("--uppercase", action="store_true", help="Include uppercase letters")
    parser.add_argument("--lowercase", action="store_true", help="Include lowercase letters")
    parser.add_argument("--prefix", default="", help="Username prefix")
    parser.add_argument("--suffix", default="", help="Username suffix")
    parser.add_argument(
        "--workers", type=int, default=75, help="Parallel workers (higher = faster but may hit rate limits)"
    )
    parser.add_argument("--batch-size", type=int, default=300, help="How many usernames to keep in flight")
    parser.add_argument("--find", type=int, default=1, help="Number of available usernames to find before stopping")
    parser.add_argument("--max-checks", type=int, default=0, help="Stop after this many checks (0 = unlimited)")
    parser.add_argument("--timeout", type=float, default=7.0, help="Request timeout in seconds")
    parser.add_argument(
        "--print-checked",
        action="store_true",
        help="Print every checked username result (slower, but useful for debugging)",
    )
    parser.add_argument(
        "--status-interval",
        type=float,
        default=2.0,
        help="Seconds between status updates",
    )
    return parser.parse_args()


def build_charset(args: argparse.Namespace) -> str:
    include_letters = args.letters or (not args.letters and not args.numbers)
    include_numbers = args.numbers or (not args.letters and not args.numbers)

    chars = ""
    if include_letters:
        include_lower = args.lowercase or not args.uppercase
        include_upper = args.uppercase
        if include_lower:
            chars += string.ascii_lowercase
        if include_upper:
            chars += string.ascii_uppercase
    if include_numbers:
        chars += string.digits

    if not chars:
        raise ValueError("No characters available. Enable letters and/or numbers.")

    return chars


def generate_username(
    charset: str,
    min_length: int,
    max_length: int,
    prefix: str,
    suffix: str,
) -> str:
    if min_length > max_length:
        raise ValueError("min-length cannot be greater than max-length")

    fixed_len = len(prefix) + len(suffix)
    if fixed_len > max_length:
        raise ValueError("prefix + suffix is longer than max-length")

    content_min = max(0, min_length - fixed_len)
    content_max = max_length - fixed_len
    if content_min > content_max:
        raise ValueError("length constraints are impossible with current prefix/suffix")

    content_len = random.randint(content_min, content_max)
    core = "".join(random.choice(charset) for _ in range(content_len))
    return f"{prefix}{core}{suffix}"


def check_username(username: str, timeout: float) -> tuple[str, bool, str]:
    params = {
        "request.username": username,
        "request.birthday": DEFAULT_BIRTHDAY,
        "request.context": "Signup",
    }
    url = f"{ROBLOX_VALIDATE_URL}?{urllib.parse.urlencode(params)}"

    req = urllib.request.Request(url, headers={"User-Agent": "Mozilla/5.0 username-checker"})

    try:
        with urllib.request.urlopen(req, timeout=timeout) as response:
            data = json.loads(response.read().decode("utf-8", errors="replace"))
    except urllib.error.HTTPError as exc:
        if exc.code == 429:
            return username, False, "RATE_LIMITED"
        return username, False, f"HTTP_{exc.code}"
    except Exception:
        return username, False, "REQUEST_FAILED"

    code = data.get("code")
    message = str(data.get("message", "")).upper()

    # Roblox returns code=0 for valid username in signup context.
    available = code == 0 or "VALID" in message

    if not available and "TAKEN" in message:
        return username, False, "TAKEN"

    return username, available, message or "UNAVAILABLE"


def run(args: argparse.Namespace) -> int:
    charset = build_charset(args)
    stats = Stats()
    seen: set[str] = set()
    found: list[str] = []

    start = time.time()
    last_status = start

    print("Starting Roblox username sniper...")
    print(
        f"Settings => length: {args.min_length}-{args.max_length}, workers: {args.workers}, "
        f"batch-size: {args.batch_size}, find: {args.find}, prefix: '{args.prefix}', suffix: '{args.suffix}'"
    )

    with ThreadPoolExecutor(max_workers=args.workers) as executor:
        future_to_username: dict[Future[tuple[str, bool, str]], str] = {}

        def submit_one() -> None:
            while True:
                candidate = generate_username(
                    charset=charset,
                    min_length=args.min_length,
                    max_length=args.max_length,
                    prefix=args.prefix,
                    suffix=args.suffix,
                )
                if candidate not in seen:
                    seen.add(candidate)
                    break
            fut = executor.submit(check_username, candidate, args.timeout)
            future_to_username[fut] = candidate

        for _ in range(max(1, args.batch_size)):
            submit_one()

        while future_to_username:
            done, _ = wait(future_to_username, return_when=FIRST_COMPLETED)
            for fut in done:
                future_to_username.pop(fut, None)
                try:
                    username, available, reason = fut.result()
                except Exception:
                    stats.add_failed()
                    username, available, reason = "<unknown>", False, "WORKER_ERROR"

                stats.add_checked(available)

                if args.print_checked:
                    tag = "AVAILABLE" if available else "taken"
                    print(f"[{tag}] {username} ({reason})")

                if available:
                    found.append(username)
                    print(f"\n[AVAILABLE] {username}\n")
                    if len(found) >= args.find:
                        checked, avail, failed = stats.snapshot()
                        elapsed = max(time.time() - start, 0.001)
                        print("Done: target reached.")
                        print(
                            f"Checked={checked} Available={avail} Failed={failed} "
                            f"Rate={checked/elapsed:.2f}/sec"
                        )
                        print("Found usernames:")
                        for name in found:
                            print(f" - {name}")
                        return 0

                checked, _, _ = stats.snapshot()
                if args.max_checks and checked >= args.max_checks:
                    elapsed = max(time.time() - start, 0.001)
                    print("Done: max-checks reached.")
                    print(f"Checked={checked} Rate={checked/elapsed:.2f}/sec")
                    print("Found usernames:")
                    for name in found:
                        print(f" - {name}")
                    return 0

                if time.time() - last_status >= args.status_interval:
                    checked, avail, failed = stats.snapshot()
                    elapsed = max(time.time() - start, 0.001)
                    print(
                        f"[status] checked={checked} available={avail} failed={failed} "
                        f"rate={checked/elapsed:.2f}/sec inflight={len(future_to_username)}"
                    )
                    last_status = time.time()

                if not args.max_checks or stats.snapshot()[0] < args.max_checks:
                    submit_one()

    return 0


def main() -> int:
    try:
        args = parse_args()
        return run(args)
    except KeyboardInterrupt:
        print("\nInterrupted by user.")
        return 130
    except Exception as exc:
        print(f"Error: {exc}")
        return 1


if __name__ == "__main__":
    raise SystemExit(main())
